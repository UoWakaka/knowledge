# 为什么需要调度器

Linux 是一个多任务的操作系统，这就意味着它可以「同时」执行多个任务。在单核处理器上，任意时刻只能有一个进程可以执行（并发）；而在多核处理器中，则允许任务并行执行。然而，不管是何种硬件类型的机器上，可能同时还有很多在内存中无法得到执行的进程，它们正在等待运行，或者正在睡眠。负责将 CPU 时间分配给进程的内核组件就是「进程调度器」。

# 调度器的职责

调度器负责维护进程调度顺序，选择下一个待执行的任务。调度器可以随时决定任意进程停止运行，而让其它进程获得 CPU 资源。这种违背正在运行的进程意愿，停止其运行的行为就是所谓的「抢占」。抢占通常可以在定时器中断时发生，当中断发生时，调度器会检查是否需要切换任务，如果是，则会完成进程上下文切换。每个进程所获得的运行时间叫做进程的时间片（timeslice）。

任务通常可以区分为交互式（I/O 密集型）、非交互式（CPU 密集型）任务和实时任务。交互式任务通常会重度依赖 I/O 操作（如 GUI 应用），并且通常用不完分配给它的时间片。而非交互式任务（如数学运算）则需要使用更多的 CPU 资源。它们通常会用完自己的时间片之后被抢占，并不会被 I/O 请求频繁阻塞。实时任务是确保它们能够在一定时间范围内执行的任务。

操作系统的调度策略就需要均衡这些任务，并且保证每个任务都能得到足够的执行资源，而不会对其它任务产生明显的性能影响。 Linux 为了保证 CPU 利用率最大化，同时又能保证更快的响应时间，倾向于为非交互式任务分配更大的时间片，但是以较低的频率运行它们；而针对 I/O 密集型任务，则会在较短周期内频繁地执行。

# 进程优先级

在 Linux 中，每一个普通任务都被赋予了一个 nice 值，它的范围是 -20 到 +19，任务默认 nice 值是 0。nice 值越高，任务优先级越低。可以通过API修改。

### 实时任务

- 硬实时任务：会有严格的时间限制，任务必须在时限内完成。比如直升机的飞控系统，就需要及时响应驾驶员的操控，并做出预期的动作。然而，Linux 本身并不支持硬实时任务，但是有一些基于它修改的版本，如 RTLinux（它们通常被称为 RTOS）则是支持硬实时调度的。

- 软实时任务：软实时任务其实也会有时间限制，但不是那么严格。也就是说，任务晚一点运行任务，并不会造成不可挽回的灾难性事故。实践中，软实时任务会提供一定的时间限制保障，但是不要过度依赖这种特性。例如，VOIP 软件会使用软实时保障的协议传来送音视频信号，但是即便因为操作系统负载过高，而产生一点延迟，也不会造成很大影响。无论如何，软实时任务总会比普通任务的优先级更高。

Linux 中实时任务的优先级范围是 0~99，但是有趣的是，它和 nice 值的作用刚好相反，这里的优先级值越大，就意味着优先级越高。

# 何时会发生调度

- 主动调用`schedule()`
- 时钟中断发生会调用`schedule_tick()`
- 当前正在运行的任务进入休眠状态, 如网络IO、磁盘IO、休眠等。

# 调度器

- 早期版本的`o(n)`调度

    遍历系统中所有的任务，找出时间片最长的任务，选择该任务执行。

    缺点: 
    
    - 任务越多, 遍历耗费时间越久
    - 无法处理多核
    - 对于实时任务度调度支持有缺陷, 因为必须要完成遍历

- 2.6 版本加入的`o(1)`调度

    O(1) 调度器为每个 CPU 维护了两个队列，即 active 和 expired。active 队列存放的是时间片尚未用完的任务，而 expired 则是时间片已经耗尽的任务。当一个任务的时间片用完后，就会被转到 expired 队列，而且会重新计算它的优先级。当 active 队列任务全部转移到 expired 队列后，会交换二者（让 active 指向 expired 队列，expired 指向 active 队列）。可以看到，优先级的计算，队列切换都和任务数量多寡无关，能够在 O(1) 时间复杂度下完成。

    缺点:

    - 高优先级的任务会一直抢占低优先级的任务, 导致低优先级的任务无法执行。

- CFS 完全公平调度器

    它实现了一个基于权重的公平队列算法，从而将 CPU 时间分配给多个任务（每个任务的权重和它的 nice 值有关，nice 值越低，权重值越高）。每个任务都有一个关联的虚拟运行时间 vruntime，它表示一个任务所使用的 CPU 时间除以其优先级得到的值。相同优先级和相同 vruntime 的两个任务实际运行的时间也是相同的，这就意味着 CPU 资源是由它们均分了。为了保证所有任务能够公平推进，每当需要抢占当前任务时，CFS 总会挑选出 vruntime 最小的那个任务运行。

    支持将一个应用中的线程打包到 cgroup 结构中，cgroup 的 vruntime 是其中所有线程的 vuntime 之和。然后 CFS 就可以将它的算法应用于cgroup 之间，从而保证公平性。当某个 cgroup 被选中后，其中拥有最小 vruntime 的线程会被执行，从而保证 cgroup 中的线程之间的公平性。

    CFS使用红黑树来维护任务, 树通过 `vruntime` 排序节点。当任务运行时增加虚拟时间, 并调整树(往右移动), 对于高优先级的任务, 虚拟时钟的节拍更慢。

- 实时调度

    Linux 实时任务调度器实现位于 `kernel/sched/rt.c`，对于系统而言，实时任务属于贵客，一旦存在实时任务需要调度，那就应当尽可能及时地为它们服务。对于实时任务而言，有两种调度策略存在

    - SCHED_FIFO: 这个其实就是一个先到先服务的调度算法。这类任务没有时间片限制，它们会一直运行直到阻塞或者主动放弃 CPU，亦或者被更高优先级的实时任务抢占。

    - SCHED_RR: 这种策略类似于 SCHED_FIFO，只是多了时间片限制。相同优先级的任务会以轮询的方式被调度，每个运行的任务都会一直运行，直到其用光自己的时间片，或者被更高优先级的任务抢占。

- BFS & MuqSS

    BFS 是一个适用于桌面或移动设备的调度器，设计地比较简洁，用于改善桌面应用的交互性，减小响应时间，提升用户体验。

    MuqSS 是作者后来基于 BFS 改进的一款调度器。每次需要在对应优先级链表中遍历查找需要执行任务，这个时间复杂度为 O(n)。所以新的调度器引入了跳表来解决该问题，从而将时间复杂度降低到 O(1)。

