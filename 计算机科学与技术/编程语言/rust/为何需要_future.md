## 为何需要 `future`

为何需要 `future` 这个问题其实等价于为何需要 `异步`。

可以有多种理解角度:

- 例如 `让慢速的操作不要阻塞下一步的操作` 当然前提是前后相互不依赖。

- 例如 期望同一时刻 `尽可能的执行更多代码`。

无论何种角度，它们的目的都是为了 `单位时间内尽可能多的执行代码，从而提升性能`。

## 和线程的区别

线程是操作系统(计算机)的一种资源，而异步是一种运行模式。如果刨根问底，异步是要依赖于线程的。

## 多线程与异步

`线程` 是一种资源，而 `多线程` 与 `异步` 一样也是一种运行模式。

`多线程` 和 `异步` 这两种模式要放在高并发的场景下才能发现区别。

究其根本，就是因为线程是一种资源，而资源并不是无限的这一事实。

在高并发场景下，太多的线程被创建，可能增加了调度的负担(*linux内核o(1)调度算法已经和进程数量无关*)，也增加了资源的消耗（内存、CPU），最后 CPU 资源是固定的，即使启动再多的线程本质上也无法达到真正的并发，平白消耗资源，导致性能下降。

而异步则把代码进行排队（计算资源池化），在固定数量的线程上执行，这样既不会抢占太多的资源，实现最佳的性能比。

**所有的高并发性能优化方案，实际上都是在解决两个问题: `无锁化、异步化`。**

## 例子

`example/rust_03`

```rust
use futures::executor;

async fn hello1() {
    println!("h1");
}

async fn hello2() {
    hello1().await; // wait hello1
    println!("h2");
}

fn main() {
    executor::block_on(hello2());
    // output:
    // h1
    // h2
}
```



